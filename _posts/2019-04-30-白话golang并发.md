---
layout: post
title:  白话Golang并发
description: 浅显易懂的Golang并发
tags:
   Golang
class: post-one
comments: true
poster: attachments/images/articles/2019-04-30/poster.jpg
---
### 白话Golang并发
**协程**：Go语言中轻量级线程的实现，由Go的运行时(runtime)管理。简单理解就是Go中用协程实现并发。  
至于协程有什么优势？为什么是协程？以后会详细说，本文只想带领小白会使用Go的并发。  

**1. 并发实现**  
　　Go语言中实现并发的方式比较简单，只要在函数前面加一个 go 就行了，可以创建匿名函数在前面加个 go。上面提到了协程的概念，当一个程序启动的时候，其主函数是在一个单独的 goroutine 中运行的，通常被叫做 main goroutine。而新的goroutine 会通过 go语句来创建。如果main goroutine 退出了那么子协程也要跟着退出。这就是在并发的场景中需要注意的，如果我们后续的程序处理依赖子协程的返回结果我们就要控制主协程的退出时间，主协程过早退出会导致数据不完成活着数据丢失的问题。　　　　　　  
```go
//例子1
func main() {
	go func() {
		fmt.Println("我是一个goroutine")
	}()
       fmt.Println("main goroutine")
}
执行结果：
  main goroutine
----------------------------------------------------------  
//例子2
func main() {
	go func() {
		fmt.Println("我是一个goroutine")
	}()
       fmt.Println("main goroutine")
       time.Sleep(time.Second)
}
执行结果：
	main goroutine
	我是一个goroutine
```
　　显然在`例子2`中子goroutine可以保证在main goroutine 执行结束之前梳理执行完成，但是在程序开发中在程序里面写sleep一定会被喷死，而且不同的场景下等待时间的不可预估的。所以我们需要一种方式，他可以自动的阻塞main goroutine，并在等所有的子协程都执行完成了在进行后续的工作。并且在`例子1`和`例子2`中并没有做批量的动作(如同时输出100 个 hello world 或者发送 1000 次 http请求并且获取到请求的结果)。　　

**2.并发控制**  
　　Go语言中实现并发(准确的说是控制并发)的方式有两种：　　
- **wait**
- **channel**

**2.1 wait**  
　　Go中的 sync 包提供了一个很有用的功能： WaitGroup，它的作用就是阻塞main goroutine的执行，一直等到所有的子协程执行完成。  　　
　　<p>WaitGroup有三个方法:</p> 
　　　(1)、Add(delta int): 添加或者减少等待goroutine的数量   　
　　　(2)、Done：相当于Add(-1)    
　　　(3)、Wait: 执行阻塞，直到所有的WaitGroup数量变成0。Wait()的特点就是可以用来阻塞知道队列中所有的任务都完成时才解除阻塞，而不是通过sleep一个固定的时间，但是其缺点就是无法指定固定的goroutine的数量(channel 可以)。    
```go
//例子3
var waitgroup sync.WaitGroup
func main() {
	var waitgroup sync.WaitGroup
	idc := []string{"1", "2", "3", "4"}
	for i := range idc {
		waitgroup.Add(1)
		go func(i int) {
			logrus.Info(idc[i])
			waitgroup.Done()
		}(i)
	}
	waitgroup.Wait()
}
执行结果：
3\n 2\n 1\n 4\n
```
　　值得一提的是通常我们会遇到这样的需求，并发的请求一类接口但是每个接口的返回值是不同的，我们需要讲这些值放到一个slice或者一个Map中，这个时候会出现变量被覆盖的情况，最后我们只能拿到最后一个数值或者是混乱的数据，这个时候我们说slice和map是并发不安全的。确保得到我们想要的结果我们需要在赋值的时候增加锁。  
```go
//例子4
var mutex sync.Mutex
func main() {
	var tt []int
	for i := 0; i < 10; i++ {
		waitgroup.Add(1)
		go func() {
			rr := rand.Intn(100)
			mutex.Lock()			
			tt = append(tt, rr)
			mutex.Unlock()
			waitgroup.Done()
		}()
	}
	waitgroup.Wait()
	logrus.Info(tt)
}
```
　　在`例子4`中对 tt 加锁之后，输出了我们想要的结果。虽然这种方式可以解决我们遇到的问题，但是对整体的并发性能还有产生了一定的影响，所以我们一般建议不要做map或者slice的并发。当然sync提供了map这里的是并发安全的或者可以尝试使用atomic解决一定场景的问题。除此之外channel是最优选择！！  
**2.2 channel**  
　　channel是Go中队列的一种实现形式，channel可以使用内置的make()函数来创建 make(chan type) 等价于 make(chan type,0)  
　　make(chan type,capacity) 当capacity = 0 时，channel是无缓冲阻塞读写的；当capacity > 0时，channel是有缓存非阻塞的，直到写满channel个元素才阻塞写入。  
　　值得注意的是 type可以是任何一种数据类型int/string/interface/struct等。  
　　基本语法：  
　　　　channel <- value //发送value到channel  
　　　　<-channel //接收并丢弃   　　
　　　　x := <-channel //从channel中接收数据，并赋值给x  
　　　　x,ok := <-channel //从channel中接收数据，并赋值给x，同时检查通道是否已经关闭或者是否为空值  
　　　那我们现在用channel的无缓冲队列实现一个`例子4`中一样的功能  
```go
var complete chan int = make(chan int)
var waitgroup sync.WaitGroup
func loop() {
	value := rand.Intn(100)
	complete <- value
}
func main() {
	var tt []int
	for i := 0; i < 10; i++ {
		go loop()
	}
	for i := 0; i < 10; i++ {
		value := <-complete
		tt = append(tt, value)
	}
	logs.Info(tt)
}
```
　　有缓冲的channel队列用法上没有什么区别。  
　　但是在实际的业务场景中我们通常需要创建多个channel队列,比如我们想写一个监控告警的功能，多条告警规则需要同时查询数据库中的信息并且查询的时间间隔也不一样，还要保证可以灵活的控制每一个规则的开始和关闭。这时候就需要两个比较实用的**close** 和 **select**  
**close**：可以显示的关闭一个channel，主要的应用场景在多个channel运行的情况下，想执行关闭某个channel。一个已经关闭的channel再次关闭会panic  
**select**：一个select语句用来选择哪个case中的发送或接收操作可以被立即执行。它类似于switch语句，但是它的case涉及到channel有关的I/O操作。简单来说select是用来监听和channel相关的I/O操作，当I/O操作发生时触发动作。  
循序渐进先模拟一个简单的场景：  
　　有两个面包师傅，一个是做草莓味面包的，一个是做香蕉味面包的，要求他们两个人同时做面包但是他们各自做的面包的包装是不同的。  
```go
//例子5
func MakeBread(taste string, cs chan string, num int) {
	for i := 1; i <= num; i++ {
		bread := fmt.Sprintf("%s面包,编号:%s", taste, strconv.Itoa(i))
		cs <- bread
	}
	close(cs)
}
func PackBread(ban_bread chan string, str_bread chan string) {
	ban_close, str_close := false, false
	for {
		if ban_close && str_close {
			return
		}
		select {
		case v, ban_ok := <-ban_bread:
			if !ban_ok {
				ban_close = true
			} else {
				fmt.Println("黄色包装", v)
			}
		case y, str_ok := <-str_bread:
			if !str_ok {
				str_close = true
			} else {
				fmt.Println("红色包装", y)
			}
		}
	}
}
func main() {
	var str_bread chan string = make(chan string)
	var ban_bread chan string = make(chan string)
	go MakeBread("草莓", str_bread, 4)
	go MakeBread("香蕉", ban_bread, 10)

	PackBread(ban_bread, str_bread)
}
```
　　`例子5`实现了对两个channel的控制。  
　　回到我们刚才说的监控的场景。场景描述如下：  
　　　支持动态创建监控规则，每个监控规则的查询数据库的条件都不同，并且任何一个监控规则需要支持随时关闭或者开启。在系统启动时需要保证所有的规则处于对应的开启状态或者是关闭状态。  

